//! Simulation context orchestration
//!
//! Manages multiple virtual radios, coordinating state changes and event generation.

use std::collections::HashMap;

use cat_protocol::{OperatingMode, Protocol, RadioModel};

use crate::radio::{VirtualRadio, VirtualRadioConfig};

/// Events generated by the simulation
#[derive(Debug, Clone)]
pub enum SimulationEvent {
    /// A radio generated output bytes
    RadioOutput { radio_id: String, data: Vec<u8> },
    /// A radio was added
    RadioAdded { radio_id: String },
    /// A radio was removed
    RadioRemoved { radio_id: String },
    /// Radio state changed
    RadioStateChanged {
        radio_id: String,
        frequency_hz: Option<u64>,
        mode: Option<OperatingMode>,
        ptt: Option<bool>,
    },
}

/// Manages the simulation of virtual radios
#[derive(Debug)]
pub struct SimulationContext {
    /// Virtual radios by ID
    radios: HashMap<String, VirtualRadio>,
    /// Pending events
    events: Vec<SimulationEvent>,
    /// Next auto-generated radio ID
    next_radio_num: u32,
}

impl SimulationContext {
    /// Create a new simulation context
    pub fn new() -> Self {
        Self {
            radios: HashMap::new(),
            events: Vec::new(),
            next_radio_num: 1,
        }
    }

    /// Add a new virtual radio with a given name and protocol
    pub fn add_radio(&mut self, name: &str, protocol: Protocol) -> String {
        let id = format!("sim-{}", self.next_radio_num);
        self.next_radio_num += 1;

        let display_name = if name.is_empty() {
            format!("Virtual Radio {}", self.next_radio_num - 1)
        } else {
            name.to_string()
        };

        let radio = VirtualRadio::new(display_name, protocol);
        self.radios.insert(id.clone(), radio);

        self.events.push(SimulationEvent::RadioAdded {
            radio_id: id.clone(),
        });

        id
    }

    /// Add a virtual radio from configuration
    pub fn add_radio_from_config(&mut self, config: VirtualRadioConfig) -> String {
        let id = format!("sim-{}", self.next_radio_num);
        self.next_radio_num += 1;

        let radio = VirtualRadio::from_config(config);
        self.radios.insert(id.clone(), radio);

        self.events.push(SimulationEvent::RadioAdded {
            radio_id: id.clone(),
        });

        id
    }

    /// Remove a virtual radio
    pub fn remove_radio(&mut self, id: &str) -> bool {
        if self.radios.remove(id).is_some() {
            self.events.push(SimulationEvent::RadioRemoved {
                radio_id: id.to_string(),
            });

            true
        } else {
            false
        }
    }

    /// Get a reference to a radio by ID
    pub fn get_radio(&self, id: &str) -> Option<&VirtualRadio> {
        self.radios.get(id)
    }

    /// Get a mutable reference to a radio by ID
    pub fn get_radio_mut(&mut self, id: &str) -> Option<&mut VirtualRadio> {
        self.radios.get_mut(id)
    }

    /// Get all radio IDs
    pub fn radio_ids(&self) -> impl Iterator<Item = &String> {
        self.radios.keys()
    }

    /// Get all radios
    pub fn radios(&self) -> impl Iterator<Item = (&String, &VirtualRadio)> {
        self.radios.iter()
    }

    /// Get the number of radios
    pub fn radio_count(&self) -> usize {
        self.radios.len()
    }

    /// Set a radio's frequency and generate events
    pub fn set_radio_frequency(&mut self, id: &str, hz: u64) -> bool {
        if let Some(radio) = self.radios.get_mut(id) {
            let old_freq = radio.frequency_hz();
            radio.set_frequency(hz);

            // Only process if frequency actually changed
            if old_freq != hz {
                self.generate_radio_events(id);
            }
            true
        } else {
            false
        }
    }

    /// Set a radio's mode and generate events
    pub fn set_radio_mode(&mut self, id: &str, mode: OperatingMode) -> bool {
        if let Some(radio) = self.radios.get_mut(id) {
            let old_mode = radio.mode();
            radio.set_mode(mode);

            // Only process if mode actually changed
            if old_mode != mode {
                self.generate_radio_events(id);
            }
            true
        } else {
            false
        }
    }

    /// Set a radio's PTT state and generate events
    pub fn set_radio_ptt(&mut self, id: &str, active: bool) -> bool {
        if let Some(radio) = self.radios.get_mut(id) {
            let old_ptt = radio.ptt();
            radio.set_ptt(active);

            // Only process if PTT actually changed
            if old_ptt != active {
                self.generate_radio_events(id);
            }
            true
        } else {
            false
        }
    }

    /// Set a radio's model
    pub fn set_radio_model(&mut self, id: &str, model: Option<RadioModel>) -> bool {
        if let Some(radio) = self.radios.get_mut(id) {
            radio.set_model(model);
            true
        } else {
            false
        }
    }

    /// Process pending radio output and generate events
    fn generate_radio_events(&mut self, id: &str) {
        if let Some(radio) = self.radios.get_mut(id) {
            // Collect all pending output (radio-encoded bytes for traffic monitor)
            while let Some(data) = radio.take_output() {
                // Generate radio output event
                self.events.push(SimulationEvent::RadioOutput {
                    radio_id: id.to_string(),
                    data,
                });
            }

            // Generate state change event
            self.events.push(SimulationEvent::RadioStateChanged {
                radio_id: id.to_string(),
                frequency_hz: Some(radio.frequency_hz()),
                mode: Some(radio.mode()),
                ptt: Some(radio.ptt()),
            });
        }
    }

    /// Drain all pending events
    pub fn drain_events(&mut self) -> Vec<SimulationEvent> {
        std::mem::take(&mut self.events)
    }

    /// Check if there are pending events
    pub fn has_events(&self) -> bool {
        !self.events.is_empty()
    }

    /// Get the number of pending events
    pub fn event_count(&self) -> usize {
        self.events.len()
    }

    /// Clear all state
    pub fn reset(&mut self) {
        self.radios.clear();
        self.events.clear();
        self.next_radio_num = 1;
    }
}

impl Default for SimulationContext {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_context() {
        let ctx = SimulationContext::new();
        assert_eq!(ctx.radio_count(), 0);
    }

    #[test]
    fn test_add_radio() {
        let mut ctx = SimulationContext::new();
        let id = ctx.add_radio("IC-7300", Protocol::IcomCIV);

        assert_eq!(ctx.radio_count(), 1);
        assert!(ctx.get_radio(&id).is_some());

        // Check event generated
        let events = ctx.drain_events();
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0], SimulationEvent::RadioAdded { .. }));
    }

    #[test]
    fn test_remove_radio() {
        let mut ctx = SimulationContext::new();
        let id = ctx.add_radio("Test", Protocol::Kenwood);
        ctx.drain_events();

        assert!(ctx.remove_radio(&id));
        assert_eq!(ctx.radio_count(), 0);

        let events = ctx.drain_events();
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0], SimulationEvent::RadioRemoved { .. }));
    }

    #[test]
    fn test_set_frequency_generates_events() {
        let mut ctx = SimulationContext::new();
        let id = ctx.add_radio("Test", Protocol::Kenwood);

        // Enable auto_info to get output on state changes
        if let Some(radio) = ctx.get_radio_mut(&id) {
            radio.set_auto_info(true);
        }
        ctx.drain_events();

        ctx.set_radio_frequency(&id, 7_074_000);

        let events = ctx.drain_events();
        assert!(!events.is_empty());

        // Should have radio output and state change events
        let has_output = events
            .iter()
            .any(|e| matches!(e, SimulationEvent::RadioOutput { .. }));
        let has_state = events
            .iter()
            .any(|e| matches!(e, SimulationEvent::RadioStateChanged { .. }));
        assert!(has_output);
        assert!(has_state);
    }

    #[test]
    fn test_multiple_radios() {
        let mut ctx = SimulationContext::new();

        let id1 = ctx.add_radio("Radio 1", Protocol::Kenwood);
        let id2 = ctx.add_radio("Radio 2", Protocol::IcomCIV);

        assert_eq!(ctx.radio_count(), 2);
        assert!(ctx.get_radio(&id1).is_some());
        assert!(ctx.get_radio(&id2).is_some());
    }

    #[test]
    fn test_reset() {
        let mut ctx = SimulationContext::new();
        ctx.add_radio("Test", Protocol::Kenwood);

        ctx.reset();

        assert_eq!(ctx.radio_count(), 0);
    }
}
