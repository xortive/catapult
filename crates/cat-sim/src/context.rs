//! Simulation context orchestration
//!
//! Manages lifecycle of virtual radios. After a radio is added, it is taken
//! and ownership transfers to the virtual radio actor task.

use std::collections::HashMap;

use cat_protocol::Protocol;

use crate::radio::{VirtualRadio, VirtualRadioConfig};

/// Events generated by the simulation
#[derive(Debug, Clone)]
pub enum SimulationEvent {
    /// A radio was added (ready to be taken by the actor)
    RadioAdded { radio_id: String },
    /// A radio was removed
    RadioRemoved { radio_id: String },
}

/// Manages the lifecycle of virtual radios
///
/// After a radio is added via `add_radio()`, it should be taken via `take_radio()`
/// to transfer ownership to the virtual radio actor task.
#[derive(Debug)]
pub struct SimulationContext {
    /// Virtual radios by ID (only present between add and take)
    radios: HashMap<String, VirtualRadio>,
    /// Pending events
    events: Vec<SimulationEvent>,
    /// Next auto-generated radio ID
    next_radio_num: u32,
}

impl SimulationContext {
    /// Create a new simulation context
    pub fn new() -> Self {
        Self {
            radios: HashMap::new(),
            events: Vec::new(),
            next_radio_num: 1,
        }
    }

    /// Add a new virtual radio with a given name and protocol
    ///
    /// Returns the radio ID. The radio should be taken via `take_radio()` when
    /// processing the `RadioAdded` event.
    pub fn add_radio(&mut self, name: &str, protocol: Protocol) -> String {
        let id = format!("sim-{}", self.next_radio_num);
        self.next_radio_num += 1;

        let display_name = if name.is_empty() {
            format!("Virtual Radio {}", self.next_radio_num - 1)
        } else {
            name.to_string()
        };

        let radio = VirtualRadio::new(display_name, protocol);
        self.radios.insert(id.clone(), radio);

        self.events.push(SimulationEvent::RadioAdded {
            radio_id: id.clone(),
        });

        id
    }

    /// Add a virtual radio from configuration
    ///
    /// Returns the radio ID. The radio should be taken via `take_radio()` when
    /// processing the `RadioAdded` event.
    pub fn add_radio_from_config(&mut self, config: VirtualRadioConfig) -> String {
        let id = format!("sim-{}", self.next_radio_num);
        self.next_radio_num += 1;

        let radio = VirtualRadio::from_config(config);
        self.radios.insert(id.clone(), radio);

        self.events.push(SimulationEvent::RadioAdded {
            radio_id: id.clone(),
        });

        id
    }

    /// Take a radio out of the context, transferring ownership
    ///
    /// This is called when processing a `RadioAdded` event to hand off the radio
    /// to the virtual radio actor task.
    pub fn take_radio(&mut self, id: &str) -> Option<VirtualRadio> {
        self.radios.remove(id)
    }

    /// Remove a virtual radio
    ///
    /// Generates a `RadioRemoved` event. If the radio was already taken,
    /// this just generates the event to signal the actor should shut down.
    pub fn remove_radio(&mut self, id: &str) -> bool {
        // Remove from map if still present (may have been taken already)
        self.radios.remove(id);

        self.events.push(SimulationEvent::RadioRemoved {
            radio_id: id.to_string(),
        });

        true
    }

    /// Get a reference to a radio by ID (only available before take_radio)
    pub fn get_radio(&self, id: &str) -> Option<&VirtualRadio> {
        self.radios.get(id)
    }

    /// Get a mutable reference to a radio by ID (only available before take_radio)
    pub fn get_radio_mut(&mut self, id: &str) -> Option<&mut VirtualRadio> {
        self.radios.get_mut(id)
    }

    /// Get all radio IDs currently in the context (before take)
    pub fn radio_ids(&self) -> impl Iterator<Item = &String> {
        self.radios.keys()
    }

    /// Get all radios currently in the context (before take)
    pub fn radios(&self) -> impl Iterator<Item = (&String, &VirtualRadio)> {
        self.radios.iter()
    }

    /// Get the number of radios currently in the context (before take)
    pub fn radio_count(&self) -> usize {
        self.radios.len()
    }

    /// Drain all pending events
    pub fn drain_events(&mut self) -> Vec<SimulationEvent> {
        std::mem::take(&mut self.events)
    }

    /// Check if there are pending events
    pub fn has_events(&self) -> bool {
        !self.events.is_empty()
    }

    /// Get the number of pending events
    pub fn event_count(&self) -> usize {
        self.events.len()
    }

    /// Clear all state
    pub fn reset(&mut self) {
        self.radios.clear();
        self.events.clear();
        self.next_radio_num = 1;
    }
}

impl Default for SimulationContext {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_context() {
        let ctx = SimulationContext::new();
        assert_eq!(ctx.radio_count(), 0);
    }

    #[test]
    fn test_add_radio() {
        let mut ctx = SimulationContext::new();
        let id = ctx.add_radio("IC-7300", Protocol::IcomCIV);

        assert_eq!(ctx.radio_count(), 1);
        assert!(ctx.get_radio(&id).is_some());

        // Check event generated
        let events = ctx.drain_events();
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0], SimulationEvent::RadioAdded { .. }));
    }

    #[test]
    fn test_take_radio() {
        let mut ctx = SimulationContext::new();
        let id = ctx.add_radio("Test", Protocol::Kenwood);

        // Take the radio
        let radio = ctx.take_radio(&id);
        assert!(radio.is_some());
        assert_eq!(radio.unwrap().id(), "Test");

        // Radio should no longer be in context
        assert_eq!(ctx.radio_count(), 0);
        assert!(ctx.get_radio(&id).is_none());

        // Taking again should return None
        assert!(ctx.take_radio(&id).is_none());
    }

    #[test]
    fn test_remove_radio() {
        let mut ctx = SimulationContext::new();
        let id = ctx.add_radio("Test", Protocol::Kenwood);
        ctx.drain_events();

        assert!(ctx.remove_radio(&id));

        let events = ctx.drain_events();
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0], SimulationEvent::RadioRemoved { .. }));
    }

    #[test]
    fn test_remove_already_taken_radio() {
        let mut ctx = SimulationContext::new();
        let id = ctx.add_radio("Test", Protocol::Kenwood);
        ctx.drain_events();

        // Take the radio first
        let _radio = ctx.take_radio(&id);

        // Remove should still generate event (for signaling actor shutdown)
        assert!(ctx.remove_radio(&id));
        let events = ctx.drain_events();
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0], SimulationEvent::RadioRemoved { .. }));
    }

    #[test]
    fn test_multiple_radios() {
        let mut ctx = SimulationContext::new();

        let id1 = ctx.add_radio("Radio 1", Protocol::Kenwood);
        let id2 = ctx.add_radio("Radio 2", Protocol::IcomCIV);

        assert_eq!(ctx.radio_count(), 2);
        assert!(ctx.get_radio(&id1).is_some());
        assert!(ctx.get_radio(&id2).is_some());
    }

    #[test]
    fn test_reset() {
        let mut ctx = SimulationContext::new();
        ctx.add_radio("Test", Protocol::Kenwood);

        ctx.reset();

        assert_eq!(ctx.radio_count(), 0);
    }
}
